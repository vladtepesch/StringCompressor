import ast
import functools
import pprint
import sys
import inspect

from StringCompressor import StringCompressor

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

if len(sys.argv) < 2:
  eprint("no filename given")
  exit()

fileName = sys.argv[1]

# reading the data from the file
with open(fileName) as f:
  inputData = f.read()

#print("Data type before reconstruction : ", type(inputData))

# reconstructing the data as a dictionary
inputData = ast.literal_eval(inputData)

#print("Data type after reconstruction : ", type(inputData))
#print(inputData)

defaultConfig = {
  # how the data variables get declared 
  'declType' : 'static const uint8_t',
  # list of additional include directives 
  'includes' : [],
  # weather to prepend a file header with no-edit note 
  'doNotEditFileHeader': False,
  # if the original Data should be prepend to the compressed data as comment
  'originalDataAsComment' : False,
  # prepend a comment with compression size to the compressed data 
  'compressionStatsAsComment' : False,
}

inputConfig = inputData.get('config', {})

inputConfig = {**defaultConfig, **inputConfig}

if inputConfig['doNotEditFileHeader']:
  print(inspect.cleandoc(f"""
         // PLEASE NOTE
         // do not edit this file
         // it is auto generated by StringCompressor from input '{fileName}'
         """),"\n")

for i in inputConfig['includes']:
  print("#include", i)

print()

for d in inputData['data']:
  d = {**inputConfig, **d}

  if not 'maxTree' in d:
    eprint(d['name'], " does not specify maxTree - using 10\n")
  compr = StringCompressor(d.get('maxTree', 10), verbose=False, treeShanon=False)
  trainStr = functools.reduce(lambda a,x : a+x, d['data'].values(), "")
  compr.trainFromString(trainStr)
  print("\n{} {}[][2] = ".format(d['declType'], d['name']))
  print(pprint.pformat(compr.decompressData).replace('[', '{').replace(']', '}')+";")
  print()

  for c in d['data'].keys():
    cd = list(compr.compressString(d['data'][c]))
    if d['compressionStatsAsComment']:
      oLen = len(d['data'][c])
      cLen = len(cd)
      print("\n// uncompressed: {} B, compr: {} B".format(oLen, cLen))
      if d['originalDataAsComment']:
        print("//")
    if d['originalDataAsComment']:
      print("\n".join(map( lambda s: "// " + s ,d['data'][c].split("\n"))))
    print("{} {}[] = ".format(d['declType'], c))
    print(pprint.pformat(cd, compact=True).replace('[', '{').replace(']', '}')+";\n")

  print()


